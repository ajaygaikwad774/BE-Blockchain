{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst Stoplight = require('./util/stoplight.js');\n\nconst cacheUtils = require('./util/rpc-cache-utils.js');\n\nconst createPayload = require('./util/create-payload.js');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst async = require('async');\n\nmodule.exports = Web3ProviderEngine;\ninherits(Web3ProviderEngine, EventEmitter);\n\nfunction Web3ProviderEngine(opts) {\n  const self = this;\n  EventEmitter.call(self);\n  self.setMaxListeners(30); // set initialization blocker\n\n  self._ready = new Stoplight(); // unblock initialization after first block\n\n  self.once('block', function () {\n    self._ready.go();\n  }); // parse options\n\n  opts = opts || {};\n  self._pollingShouldUnref = opts.pollingShouldUnref !== false;\n  self._pollingInterval = opts.pollingInterval || 4000; // local state\n\n  self.currentBlock = null;\n  self._providers = [];\n} // public\n\n\nWeb3ProviderEngine.prototype.start = function () {\n  const self = this; // start block polling\n\n  self._startPolling();\n};\n\nWeb3ProviderEngine.prototype.stop = function () {\n  const self = this; // stop block polling\n\n  self._stopPolling();\n};\n\nWeb3ProviderEngine.prototype.addProvider = function (source) {\n  const self = this;\n\n  self._providers.push(source);\n\n  source.setEngine(this);\n};\n\nWeb3ProviderEngine.prototype.send = function (payload) {\n  throw new Error('Web3ProviderEngine does not support synchronous requests.');\n};\n\nWeb3ProviderEngine.prototype.sendAsync = function (payload, cb) {\n  const self = this;\n\n  self._ready.await(function () {\n    if (Array.isArray(payload)) {\n      // handle batch\n      async.map(payload, self._handleAsync.bind(self), cb);\n    } else {\n      // handle single\n      self._handleAsync(payload, cb);\n    }\n  });\n}; // private\n\n\nWeb3ProviderEngine.prototype._handleAsync = function (payload, finished) {\n  var self = this;\n  var currentProvider = -1;\n  var result = null;\n  var error = null;\n  var stack = [];\n  next();\n\n  function next(after) {\n    currentProvider += 1;\n    stack.unshift(after); // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));\n    } else {\n      try {\n        var provider = self._providers[currentProvider];\n        provider.handleRequest(payload, next, end);\n      } catch (e) {\n        end(e);\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error;\n    result = _result;\n    async.eachSeries(stack, function (fn, callback) {\n      if (fn) {\n        fn(error, result, callback);\n      } else {\n        callback();\n      }\n    }, function () {\n      // console.log('COMPLETED:', payload)\n      // console.log('RESULT: ', result)\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      };\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        }; // respond with both error formats\n\n        finished(error, resultObj);\n      } else {\n        self._inspectResponseForNewBlock(payload, resultObj, finished);\n      }\n    });\n  }\n}; //\n// from remote-data\n//\n\n\nWeb3ProviderEngine.prototype._startPolling = function () {\n  const self = this;\n\n  self._fetchLatestBlock();\n\n  self._pollIntervalId = setInterval(function () {\n    self._fetchLatestBlock();\n  }, self._pollingInterval); // Tell node that block polling shouldn't keep the process open.\n  // https://nodejs.org/api/timers.html#timers_timeout_unref\n\n  if (self._pollIntervalId.unref && self._pollingShouldUnref) {\n    self._pollIntervalId.unref();\n  }\n};\n\nWeb3ProviderEngine.prototype._stopPolling = function () {\n  const self = this;\n  clearInterval(self._pollIntervalId);\n};\n\nWeb3ProviderEngine.prototype._fetchLatestBlock = function (cb) {\n  if (!cb) cb = function (err) {\n    if (err) return console.error(err);\n  };\n  const self = this;\n\n  self._fetchBlock('latest', function (err, block) {\n    if (err) {\n      self.emit('error', err);\n      return cb(err);\n    }\n\n    if (!self.currentBlock || 0 !== self.currentBlock.hash.compare(block.hash)) {\n      self._setCurrentBlock(block);\n    }\n\n    cb(null, block);\n  });\n};\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function (block) {\n  const self = this;\n  self.currentBlock = block;\n  self.emit('block', block);\n};\n\nWeb3ProviderEngine.prototype._fetchBlock = function (number, cb) {\n  const self = this; // skip: cache, readiness, block number rewrite\n\n  self._handleAsync(createPayload({\n    method: 'eth_getBlockByNumber',\n    params: [number, false]\n  }), function (err, resultObj) {\n    if (err) return cb(err);\n    if (resultObj.error) return cb(resultObj.error);\n    var data = resultObj.result; // json -> buffers\n\n    var block = {\n      number: ethUtil.toBuffer(data.number),\n      hash: ethUtil.toBuffer(data.hash),\n      parentHash: ethUtil.toBuffer(data.parentHash),\n      nonce: ethUtil.toBuffer(data.nonce),\n      sha3Uncles: ethUtil.toBuffer(data.sha3Uncles),\n      logsBloom: ethUtil.toBuffer(data.logsBloom),\n      transactionsRoot: ethUtil.toBuffer(data.transactionsRoot),\n      stateRoot: ethUtil.toBuffer(data.stateRoot),\n      receiptsRoot: ethUtil.toBuffer(data.receiptRoot || data.receiptsRoot),\n      miner: ethUtil.toBuffer(data.miner),\n      difficulty: ethUtil.toBuffer(data.difficulty),\n      totalDifficulty: ethUtil.toBuffer(data.totalDifficulty),\n      size: ethUtil.toBuffer(data.size),\n      extraData: ethUtil.toBuffer(data.extraData),\n      gasLimit: ethUtil.toBuffer(data.gasLimit),\n      gasUsed: ethUtil.toBuffer(data.gasUsed),\n      timestamp: ethUtil.toBuffer(data.timestamp),\n      transactions: data.transactions\n    };\n    cb(null, block);\n  });\n};\n\nWeb3ProviderEngine.prototype._inspectResponseForNewBlock = function (payload, resultObj, cb) {\n  // these methods return responses with a block reference\n  if (payload.method != 'eth_getTransactionByHash' && payload.method != 'eth_getTransactionReceipt') {\n    return cb(null, resultObj);\n  }\n\n  if (resultObj.result == null || resultObj.result.blockNumber == null) {\n    return cb(null, resultObj);\n  }\n\n  var blockNumber = ethUtil.toBuffer(resultObj.result.blockNumber); // If we found a new block number on the result,\n  // fetch the block details before returning the original response.\n  // We do this b/c a user might be polling for a tx by hash,\n  // and when getting a response may assume that we are on the new block and\n  // try to query data from that block but would otherwise get old data due to\n  // our blockTag-rewriting mechanism\n\n  if (0 !== this.currentBlock.number.compare(blockNumber)) {\n    this._fetchLatestBlock(function (err, block) {\n      cb(null, resultObj);\n    });\n  } else {\n    cb(null, resultObj);\n  }\n}; // util\n\n\nfunction SourceNotFoundError(payload) {\n  return new Error('Source for RPC method \"' + payload.method + '\" not found.');\n}","map":null,"metadata":{},"sourceType":"script"}