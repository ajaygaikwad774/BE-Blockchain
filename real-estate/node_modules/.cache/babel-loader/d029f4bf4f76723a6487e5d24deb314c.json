{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\nconst async = require('async');\n\nconst inherits = require('util').inherits;\n\nconst extend = require('xtend');\n\nconst Semaphore = require('semaphore');\n\nconst Subprovider = require('./subprovider.js');\n\nconst estimateGas = require('../util/estimate-gas.js');\n\nmodule.exports = HookedWalletSubprovider; // handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\n\nfunction HookedWalletSubprovider(opts) {\n  const self = this; // control flow\n\n  self.nonceLock = Semaphore(1); // data lookup\n\n  if (!opts.getAccounts) throw new Error('ProviderEngine - HookedWalletSubprovider - did not provide \"getAccounts\" fn in constructor options');\n  self.getAccounts = opts.getAccounts; // high level override\n\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage; // approval hooks\n\n  if (opts.approveTransaction) self.approveTransaction = opts.approveTransaction;\n  if (opts.approveMessage) self.approveMessage = opts.approveMessage; // actually perform the signature\n\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction;\n  if (opts.signMessage) self.signMessage = opts.signMessage; // publish to network\n\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction;\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n\n  switch (payload.method) {\n    case 'eth_coinbase':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        var result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n\n    case 'eth_accounts':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n\n    case 'eth_sendTransaction':\n      var txParams = payload.params[0];\n      async.waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_sign':\n      var address = payload.params[0];\n      var message = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n\n      var extraParams = payload.params[2] || {};\n      var msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      async.waterfall([cb => self.validateMessage(msgParams, cb), cb => self.processMessage(msgParams, cb)], end);\n      return;\n\n    default:\n      next();\n      return;\n  }\n};\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  const self = this;\n  async.waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeAndSubmitTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  const self = this;\n  async.waterfall([cb => self.approveMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n};\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    async.waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.signTransaction = function (tx, cb) {\n  cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"signTransaction\" fn in constructor options'));\n};\n\nHookedWalletSubprovider.prototype.signMessage = function (msg, cb) {\n  cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"signMessage\" fn in constructor options'));\n};\n\nHookedWalletSubprovider.prototype.approveTransaction = function (txParams, cb) {\n  cb(null, true);\n};\n\nHookedWalletSubprovider.prototype.approveMessage = function (txParams, cb) {\n  cb(null, true);\n};\n\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (txParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign transaction.\"));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign transaction for this address: \\\"\".concat(txParams.from, \"\\\"\")));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(\"Undefined address - from address required to sign message.\"));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(\"Unknown address - unable to sign message for this address: \\\"\".concat(msgParams.from, \"\\\"\")));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (senderAddress === undefined) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    var senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n};\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  const self = this;\n  var address = txParams.from; // console.log('fillInTxExtras - address:', address)\n\n  var reqs = {};\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    reqs.gasPrice = self.emitPayload.bind(self, {\n      method: 'eth_gasPrice',\n      params: []\n    });\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    reqs.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    reqs.gas = estimateGas.bind(null, self.engine, cloneTxParams(txParams));\n  }\n\n  async.parallel(reqs, function (err, result) {\n    if (err) return cb(err); // console.log('fillInTxExtras - result:', result)\n\n    var res = {};\n    if (result.gasPrice) res.gasPrice = result.gasPrice.result;\n    if (result.nonce) res.nonce = result.nonce.result;\n    if (result.gas) res.gas = result.gas;\n    cb(null, extend(res, txParams));\n  });\n}; // util\n// we use this to clean any custom params from the txParams\n\n\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\n\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}","map":null,"metadata":{},"sourceType":"script"}